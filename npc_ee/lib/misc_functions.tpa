
//ADD SPELLSTATE MACRO______________________________________________________________
//
DEFINE_ACTION_FUNCTION d5_resolve_state INT_VAR index=0 delete=0 STR_VAR new_state_id = ~blah~ RET new_state_ind BEGIN
 OUTER_SET min_new=118
 COPY_EXISTING ~splstate.ids~ override
  new_state_ind=0
  found=0
  READ_2DA_ENTRIES_NOW stats 2
  FOR (row=0;row<stats;row+=1) BEGIN
    READ_2DA_ENTRY_FORMER stats row 0 ind
    READ_2DA_ENTRY_FORMER stats row 1 str
    SET $stat("%row%") = ind
    PATCH_IF index BEGIN
      PATCH_IF ind=index BEGIN
        REMOVE_2DA_ROW row 2
        found=1
        PATCH_IF delete=0 BEGIN
          INSERT_2DA_ROW row 2 ~%index% %new_state_id%~
        END
        row=stats
      END
    END ELSE BEGIN
      PATCH_IF ~%str%~ STRING_EQUAL_CASE ~%new_state_id%~ BEGIN
        new_state_ind=ind
        found=1
     /* row=stats */ // don't stop looking, the same ID may be assigned to a greater index, which takes priority when compiling
      END
    END
  END
  PATCH_IF found=0 BEGIN
    new_state_ind=min_new
    PHP_EACH stat AS row => ind BEGIN
      PATCH_IF found=0 && (row+1 < stats) BEGIN // not at the end of file
        next_row = row+1
        next_ind = EVAL $stat("%next_row%")
        PATCH_IF index BEGIN
          PATCH_IF index<next_ind && index>ind BEGIN
            INSERT_2DA_ROW next_row 2 ~%index% %new_state_id%~
            found=1
          END
        END ELSE BEGIN
          PATCH_IF new_state_ind<next_ind BEGIN
            PATCH_IF ind<new_state_ind BEGIN
              INSERT_2DA_ROW next_row 2 ~%new_state_ind% %new_state_id%~
              found=1
            END ELSE BEGIN
              new_state_ind+=1
              PATCH_IF new_state_ind<next_ind BEGIN
                INSERT_2DA_ROW next_row 2 ~%new_state_ind% %new_state_id%~
                found=1
              END
            END
          END
        END
      END ELSE BEGIN // at the end of file
        PATCH_IF found=0 BEGIN
          PATCH_IF index BEGIN
            INSERT_2DA_ROW stats 2 ~%index% %new_state_id%~
          END ELSE BEGIN
            PATCH_IF new_state_ind>ind BEGIN
              INSERT_2DA_ROW stats 2 ~%new_state_ind% %new_state_id%~
            END ELSE BEGIN
              new_state_ind+=1
              INSERT_2DA_ROW stats 2 ~%new_state_ind% %new_state_id%~
            END
          END
        END
      END
    END // PHP_EACH
  END
END


//__________________________________________________________________________________
//__________________________________________________________________________________
//__________________________________________________________________________________
//__________________________________________________________________________________


// Automatically fixes missing column entries in 2da files. Can be used as both patch and action function

DEFINE_ACTION_FUNCTION 2DA_MISSING_COLS
	INT_VAR
	cols = 0 //minimum amount of columns that should have values (if not set function will automatically read max number of columns in file)
	STR_VAR
	2da = ~~ //2da file that should be patched, e.g. kitlist
	entry = ~~ //what entry should be set in missing columns (if not set function will automatically read default entry from loaded 2da, e.g. *)
BEGIN
	ACTION_IF ~%2da%~ STR_EQ ~~ BEGIN
		FAIL ~2DA_MISSING_COLS: %2da% STR_VAR not set~
	END
	COPY_EXISTING ~%2da%.2da~ ~override~
		PRETTY_PRINT_2DA
		PATCH_IF ~%entry%~ STR_EQ ~~ BEGIN
			READ_2DA_ENTRY 1 0 1 "entry"
		END
		PATCH_IF cols = 0 BEGIN
			COUNT_2DA_COLS "cols"
		END
		SET cnt = 0
		REPLACE_EVALUATE ~^\(.+\)$~ BEGIN
			PATCH_IF cnt >= 3 BEGIN
				INNER_PATCH_SAVE MATCH1 ~%MATCH1%~ BEGIN
					COUNT_REGEXP_INSTANCES ~ +~ num_matches
					WHILE (num_matches < (cols - 1)) BEGIN
						REPLACE_TEXTUALLY ~$~ ~ %entry%~
						SET num_matches = num_matches + 1
					END
				END
			END ELSE BEGIN
				SET cnt = cnt + 1
			END
		END ~%MATCH1%~
		PRETTY_PRINT_2DA
	BUT_ONLY
END

DEFINE_PATCH_FUNCTION 2DA_MISSING_COLS
	INT_VAR
	cols = 0 //minimum amount of columns that should have values (if not set function will automatically read max number of columns in file)
	STR_VAR
	entry = ~~ //what entry should be used in missing columns (if not set function will automatically read default entry from loaded 2da, e.g. *)
BEGIN
	PRETTY_PRINT_2DA
	PATCH_IF ~%entry%~ STR_EQ ~~ BEGIN
		READ_2DA_ENTRY 1 0 1 "entry"
	END
	PATCH_IF cols = 0 BEGIN
		COUNT_2DA_COLS "cols"
	END
	SET cnt = 0
	REPLACE_EVALUATE ~^\(.+\)$~ BEGIN
		PATCH_IF cnt >= 3 BEGIN
			INNER_PATCH_SAVE MATCH1 ~%MATCH1%~ BEGIN
				COUNT_REGEXP_INSTANCES ~ +~ num_matches
				WHILE (num_matches < (cols - 1)) BEGIN
					REPLACE_TEXTUALLY ~$~ ~ %entry%~
					SET num_matches = num_matches + 1
				END
			END
		END ELSE BEGIN
			SET cnt = cnt + 1
		END
	END ~%MATCH1%~
	PRETTY_PRINT_2DA
END


//__________________________________________________________________________________
//__________________________________________________________________________________
//__________________________________________________________________________________
//__________________________________________________________________________________


//JOINABLE NPCS ARRAY MACRO__________________________________________________________
//
DEFINE_ACTION_MACRO JOINABLE_NPC_ARRAYS BEGIN
	//PDIALOG.2DA exists in all games
	ACTION_DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_2da BEGIN ~PDIALOG~ => ~~ END
	//Check PDIALOG.2DA file variants referenced in CAMPAIGN.2DA
	ACTION_IF FILE_EXISTS_IN_GAME ~CAMPAIGN.2DA~ BEGIN
		COPY_EXISTING ~CAMPAIGN.2DA~ ~CAMPAIGN.2DA~
			COUNT_2DA_ROWS 32 "cntrow"
			FOR (i = 0; i < cntrow; i = i + 1) BEGIN
				READ_2DA_ENTRY i 11 32 file
				TO_UPPER file
				DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_2da BEGIN ~%file%~ => ~~ END
			END
		BUT_ONLY
	END
	//Generate array with joinable NPC DV
	ACTION_PHP_EACH JOINABLE_NPC_ARRAY_2da AS file => ~~ BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME ~%file%.2da~ BEGIN
			COPY_EXISTING ~%file%.2da~ ~override~
				COUNT_2DA_ROWS 3 "cntrow"
				FOR (i = 1; i < cntrow; i = i + 1) BEGIN
					READ_2DA_ENTRY i 0 3 "dv"
					TO_UPPER dv
					DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_dv BEGIN ~%dv%~ => ~~ END
				END
			BUT_ONLY
		END
	END
	//Generate array with joinable NPC cre files
	COPY_EXISTING_REGEXP GLOB ~.+\.CRE~ ~override~
	  PATCH_IF (%SOURCE_SIZE% > 0x2a8) BEGIN
		READ_ASCII 0x280 "deathvar" (32) NULL
		TO_UPPER deathvar
		PATCH_IF VARIABLE_IS_SET $JOINABLE_NPC_ARRAY_dv(~%deathvar%~) BEGIN
			DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY BEGIN ~%SOURCE_FILE%~ => ~%deathvar%~ END
		END
		PATCH_IF NOT VARIABLE_IS_SET $JOINABLE_NPC_ARRAY_dv(~%dv%~) BEGIN
			DEFINE_ASSOCIATIVE_ARRAY NON_JOINABLE_NPC_ARRAY BEGIN ~%SOURCE_FILE%~ => ~%deathvar%~ END
		END
	  END
	BUT_ONLY
END


//__________________________________________________________________________________
//__________________________________________________________________________________
//__________________________________________________________________________________
//__________________________________________________________________________________


